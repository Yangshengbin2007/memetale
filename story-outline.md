# memetale rpg – Story Outline

> A clichéd story, told in a different way.  
> Heavy on narrative, choices, and memes.

---

## 1. World & Tone

### 1.1 Worldview: memetale

- 表面世界：
  - 经典童话王国：城堡、公主、恶龙、勇者王子。
  - 大陆名字叫 **memetale**，表面解释为“记忆与传说交织的大陆”。
- 真相（meta 向）【待具体补充】：
  - 例如：其实是一个不断被重置的童话剧本存档空间。
  - 所有角色都是「被复用的模板」，只是在不同周目里被稍微改写。
  - 世界中偶尔出现“数据裂缝”（bug/裂纹/空无房间）来暗示这一点。
- 风格：
  - 7 成是传统 RPG 剧情+解谜。
  - 3 成是 meta、自我吐槽和梗（第四面墙、游戏梗、网络梗）。

### 1.2 Core Themes

- **选择与不后悔**
  - 玩家被不断迫使做出选择，有些看起来“无所谓”的选择其实影响很大。
  - 真结局强调：不是所有选择都能完美，但你得对“当下的自己”负责。
- **真相 vs 故事**
  - 公主被抓只是“故事壳子”，背后真相与「谁在讲故事」有关。
- **meme 的使用原则**
  - 不单是为了搞笑，而是：
    - 用梗来隐藏线索（只有懂梗的人才会联想到真相的一角）。
    - 用烂梗来表现“剧本老化/重置次数太多”。

---

## 2. Main Characters

### 2.1 The Prince (Player)

- 表面设定：
  - 标准 RPG 勇者形象：勇敢、单纯、“你是命中注定的英雄”。
- 深层设定【待决定】：
  - 例如：多周目残留记忆的载体，每次周目清除不彻底，留下些“既视感”。
  - 偶尔对 NPC 的台词产生「这句话好像在哪听过」的吐槽（meme 化）。
- 人物弧光：
  - 从“只想通关救公主”到“质疑这个世界是否真实”，再到“选择要不要打破剧本”。

### 2.2 The Princess

- 表面设定：
  - 善良/温柔/典型被动角色。
- 反转点【待细化】：
  - 可能实际上是“系统的核心进程”或“原作者的投影”。
  - 玩家是否真的要“救”她，或者她其实现一直在救玩家。
- 在不同结局中的状态：
  - True Ending：揭示真相后的真实态度和选择。
  - Hidden Ending：可能有「公主黑化线」或「公主和玩家联手脱离系统线」。

### 2.3 The Dragon

- 表面设定：
  - 传统 BOSS：恶龙、最终战。
- 真相设定【待细化】：
  - 像是 memetale世界的“垃圾回收器”/“防火墙”，设计目的是阻止剧本被破坏。
  - 它吃掉的是“异常数据”和“跑出剧本的角色”。
- 不同路线中的形象：
  - 正常线：传统最终 Boss。
  - Hidden 线：和玩家对话，吐槽自己只是背锅怪。

### 2.4 Key NPCs（示例位）

- NPC A：旅店老板
  - 表面：普通旅店老板，负责提供存档点（save）。
  - 实际：知道“存档”的本质（比如一次次重来的记忆碎片）。
  - 常用梗：关于“SL 大法”“别读档了面对现实吧”等。
- NPC B：神秘披风人
  - 表面：到处出现，给出谜语或 cryptic 提示。
  - 实际：可能是前几周目的残留意识 / 作者的影子。
- NPC C：吐槽役
  - 存在意义：专门负责 meta 吐槽流程、帮玩家总结前情、指出“你是不是又选了奇怪的选项”。

---

## 3. Chapter Structure

> 每章可以映射到一个或多个游戏场景（Scene），便于后续和代码对应。

### 3.1 Prologue – The Beginning (Chapter 0)

- 场景：王宫 / 出发前夜。
- 目的：
  - 交代基本设定（公主被龙抓走）。
  - 顺便用 NPC 吐槽「又是这个老掉牙剧情」——第一次抛 meme。
- 关键事件：
  - 国王说明任务（可选择跳过/打断）。
  - 玩家可以在房间里自由探索，发现几本“前几周目的日志”（如果设定多周目）。
- 重要 Flag 示例：
  - `flag_listen_to_king_story`：是否耐心听完剧情说明。
  - `flag_find_old_diary`：是否发现旧日志（影响后面对真相的敏感度）。

### 3.2 First Cave – Tutorial & First Meme (Chapter 1)

- 场景：通往第一洞穴的道路 + 洞穴内部。
- 玩法重点：
  - 引导基础操作（移动、对话、解谜提示）。
  - 第一次小型谜题或迷宫。
- meme 设计：
  - 教程 NPC 吐槽「按 X 键前进，我知道你其实已经按了 N 次了」。
  - 一个房间只有一个箱子，打开发现“新手装备（烂梗 T 恤）”。
- 关键选择：
  - 是否帮助一个看似无关紧要的 NPC（后面决定 TA 是否在结局出现）。
  - 是否在存档点前任性不存，导致后面一个 bad ending 的机会。

### 3.3 Second Area / Cave – Cracks in the Story (Chapter 2)

- 场景：更复杂的洞穴 / 村庄 + 洞穴组合。
- 目的：
  - 开始让玩家明显感觉到“世界不太对劲”。
  - 更多 meta 和系统级梗（时间回溯、场景重复、台词错乱）。
- 事件示例：
  - 某个 NPC 说完话后画面短暂抖动，台词被“回收/重写”。
  - 出现一个房间，里面什么都没有，只有一个“NullPointer Wizard”在那边发呆。
- Flag 示例：
  - `flag_help_villager`：是否帮某个村民解决问题。
  - `flag_enter_glitched_room`：是否进入奇怪的 bug 房间。
  - 这些 flag 会在后面影响隐藏结局。

### 3.4 Third Area / Cave – Meta Overload (Chapter 3)

- 场景：接近龙之城的区域 / 残破数据区。
- 目的：
  - 大量 meta 暗示 + 局部真相揭示。
  - 玩家明显可以感到自己「身处一个会被重置的故事」。
- 事件示例：
  - 与“吐槽役 NPC”对峙，对方直接问玩家：“你玩过几次了？”
  - 对话框出现“脚本变量名”“占位符没被替换的文本”等。
- 关键选择：
  - `flag_confront_truth`：面对真相时，选择继续追问 or 逃避。
  - `flag_trust_mysterious_npc`：是否选择相信某个重要 NPC。

### 3.5 Final – Dragon’s Lair & Endings

- 场景：龙之城 / 最高塔。
- 核心：
  - 和龙的决战/对话（不一定是纯战斗，可以是对话 + 解谜 + 若干战斗）。
  - 根据此前所有 Flag 决定进入哪条结局路线。
- 决策点：
  - 是否挥剑砍向龙。
  - 是否选择“救出”公主，或「打破剧本」。
  - 是否牺牲自己 / 回到循环中 / 跳出循环。

---

## 4. Endings

### 4.1 True Ending

- 条件（示例）：
  - 已见过大部分重要剧情 flag：`flag_find_old_diary`, `flag_enter_glitched_room`, `flag_trust_mysterious_npc`, `flag_confront_truth` 等。
  - 最终选择中，玩家选择**面对真相并承担后果**。
- 内容大意【待填】：
  - 王子与公主联手“改写” memetale 的规则。
  - 龙作为系统守护者，选择“放手”或“协助”，而不是被打死。
  - 玩家意识到：真正的救赎不是把剧情通关一次，而是接受不完美、接受失去的可能性。

### 4.2 Hidden Ending A – 深度探索线

- 条件：
  - 收集到若干隐藏梗 / 隐藏房间 / 特定解谜一次性通关。
- 可能方向：
  - 玩家解锁了“作者房间”，和作者对话，看到 memetale 的最初设定文档。
  - 世界短暂变成 debug 界面，所有角色以“变量名”身份出现。

### 4.3 Hidden Ending B – 黑梗 / 高度 Meta 线

- 条件：
  - 在多数关键选择中选了“看似错误的梗选项”，却意外触发隐藏逻辑。
- 可能方向：
  - 玩家被系统识别为“bug 本人”，于是获得“管理员权限”。
  - 游戏 UI 整个崩坏成一片梗海（当然在实现时要可控）。

### 4.4 Bad Endings（若干）

简略列几个模板，具体你之后可以一个个起名和写剧情：

- Bad Ending 1：草率冲进某个洞穴，被一击秒（经典“你死了”梗）。
- Bad Ending 2：一直逃避真相，最后永远卡在「初始村」的循环里。
- Bad Ending 3：过于依赖存档读档，被系统识别为“时间线污染者”，直接删档。

---

## 5. Key Choices & Flags (for Implementation)

> 这一节方便之后在代码里实现分支和存档，只列出“变量名 + 含义”。

示例（可根据需要增删、重命名）：

- `flag_listen_to_king_story` – 是否认真听完国王的长篇剧情说明。
- `flag_find_old_diary` – 是否在序章中找到旧日志。
- `flag_help_villager` – 是否帮助第二章某个村民。
- `flag_enter_glitched_room` – 是否进入奇怪的 bug 房间。
- `flag_trust_mysterious_npc` – 是否在关键对话中相信神秘 NPC。
- `flag_confront_truth` – 面对真相时是选择直面还是逃避。
- `flag_spare_dragon` – 最终是否选择饶恕恶龙。
- `flag_save_princess` – 最终是否执行“传统救公主”的剧本。

> 之后可以在游戏代码中用一个 `GameState` / `StoryState` 类来记录这些 flag，并在结局判断逻辑中使用。

---

## 6. Meme Distribution Notes

简单标记每章的梗类型，方便之后往里填充具体段子：

- Chapter 0：
  - 童话老套梗、开场长篇废话、教程提示梗。
- Chapter 1：
  - 新手村、史诗破烂装备、存档点、史莱姆/小怪的自嘲。
- Chapter 2：
  - 数据 bug、台词被改写、时间回滚、地图贴图错误。
- Chapter 3：
  - 开始出现脚本变量、注释、开发者吐槽。
- Final：
  - LOG 输出、堆栈信息（软表现）、作者对话、玩家 meta 向问答。

> 具体梗可以随时往这里追加，等稳定后再映射为游戏内的对话和事件。

---

## 7. From Story to Implementation (Design Checklist)

> 本节不写具体代码，只列出从剧情到代码实现时需要准备的系统与文档。

### 7.1 Scene & Flow Design

- 为每个章节/重要地点规划对应的 **Scene**：
  - PrologueScene、FirstCaveScene、SecondAreaScene、ThirdAreaScene、FinalLairScene 等。
- 记录每个 Scene 的：
  - 进入条件（需要哪些 Flag / 剧情进度）。
  - 退出条件（完成谜题 / 做出选择 / 触发战斗）。
  - 与其他 Scene 的跳转关系（简单画成状态图）。

### 7.2 Dialogue & Event System

- 决定对话数据格式（例如 JSON / YAML / 自定义文本）：
  - 每条对话需要字段：
    - `id`：对话节点 ID
    - `speaker`：说话人
    - `text`：文本内容
    - `next`：下一条对话 ID
    - `choices`：玩家可选项（文本 + 对应的下一 ID + 改变的 Flag）
    - `triggerFlags` / `requiredFlags`：进入该节点的条件与副作用
- 规划一个简单的“对话脚本示例”，方便后续在代码里解析。

### 7.3 StoryState / GameState Design

- 设计一个统一的状态记录结构（在代码中可能是 `StoryState` 或 `GameState`）：
  - 存储：
    - 所有 Flag（本文件第 5 节列出的那些）。
    - 当前章节/Scene 标识。
    - 已达成的结局列表（用于结局画廊 / 多周目要素）。
- 决定：
  - Flag 的存储形式（布尔、枚举、整数计数等）。
  - 在何处修改 Flag（对话选择 / 解谜结果 / 战斗结局）。

### 7.4 Save/Load System Plan

- 定义存档中必须保存的信息：
  - 当前 Scene / 章节。
  - 当前 StoryState / GameState 中所有关键变量。
  - 玩家位置（如有自由移动）。
- 决定存档格式（文本 / JSON / 二进制均可，按课程要求选择）。
- 规划存档点逻辑：
  - 哪些场景有存档点。
  - 是否允许任意位置快速存档（会影响 bad ending 设计，比如“滥用读档被系统拉黑”）。

### 7.5 Puzzle / Mini-game Integration

- 为每个谜题 / mini-game 记录：
  - 出现章节与场景。
  - 成功与失败分别修改哪些 Flag。
  - 是否可重复尝试，是否影响隐藏结局。
- 在实现层面抽象出一个接口（例如 `Puzzle`）：
  - 核心方法（如 `start()`, `update()`, `isCompleted()`, `getResult()` 等）先在设计文档中写清，再写代码。

### 7.6 UI / UX Notes

- 对话 UI：
  - 是否需要立绘、名字框、自动播放/快进等。
  - 玩家选项如何高亮、如何提示有多个分支。
- 场景转换：
  - 是否做淡入淡出、黑屏提示“记忆重构中”等效果。
- 结局展示：
  - 每个 Ending 是否有单独的标题画面/CG。
  - 是否在标题菜单中解锁“Gallery”或“Ending List”。

> 这些小节可以在你正式写代码之前先补充为更详细的设计说明，写清楚“**做什么**”和“**怎么连到故事**”，然后在 Java 代码中用接口/类一步步落地。

